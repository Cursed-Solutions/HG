{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started","text":"<p>Hikari is a powerful Python library which lets you program bots to do all sorts of things on Discord.</p> <p>Before using this guide to learn Hikari it's recommended that you make sure you understand basic concepts and how they work in Python such as object-oriented, and asynchronous programming. This knowledge is really important for properly grasping libraries like Hikari.</p> <p>If that all seems like a bit much for you and you don't really have a firm grasp on Python yet then I recommend trying a basics course (like Real Python) before using Hikari as libraries like this can be challenging to use without that foundational knowledge.</p> <p>So to start off we should work out what type of bot you want to use.</p> <pre><code>cache_components = (\n    hikari.api.CacheComponents.GUILD_CHANNELS\n    | hikari.api.CacheComponents.ROLES\n    | hikari.api.CacheComponents.GUILDS\n    | hikari.api.CacheComponents.MEMBERS\n)\nbot = hikari.GatewayBot(\n    os.environ[\"TOKEN\"].strip(),\n    cache_settings=hikari.impl.CacheSettings(components=cache_components),\n    intents=hikari.Intents.ALL_UNPRIVILEGED,\n)\n\nactivity = hikari.Activity(\n    name=\"Hello world!\", type=hikari.ActivityType.LISTENING\n)\nbot.run(activity=activity)\n</code></pre> <p>Gateway bots are what you'll most likely want. These allow you to listen for actions happening on Discord by subscribing to events. All a gateway bot needs to work is a bot token, and an internet connection which can reach Discord and maintain a persistent connection.</p> <p>The example above shows how you'd initiate and the standard gateway bot implementation, it should be noted that the only required argument here is the token (first argument). The other arguments configure what entities this should cache in-process and the \"intents\" which indicate what events the bot wants to receive, more information on these can be found in events.</p> <pre><code>bot = hikari.RESTBot(os.environ[\"TOKEN\"].strip(), \"Bot\")\n\nbot.run(path=\"192.168.1.102\", port=8000)\n</code></pre> <p>While there's a lot less direct configuration to RESTBots than Gateway bot, there's a bit more to getting it working than with Gateway bot. The RESTBot runs a REST server which is meant to receive interaction requests from Discord; this limits it to only knowing when users actively interact with the bot through using components and slash commands but also means that before this can work you need to have the network setup to allow Discord to connect to your bot.</p> <p>The example above shows how you'd initiate the standard REST bot implementation, it should be noted that the only requirement arguments here are the token (first argument) and the token type (second argument). Before this this'll work though you'll need to have that pesky networking setup; this means having a domain name with ssl support which points towards the IP the RESTBot is behind (Discord won't accept a raw IP address). You should keep the RESTBot behind a reverse proxy with ssl enabled locally instead of exposing it straight to the public internet to keep the payloads encrypted in-transit.</p> <p></p> <p>Once you've got the networking setup and the bot running you'll want to enter the bot's web address here to tell Discord to start sending interaction requests to the bot. You should see a failed Ping request before a successful one in the logs as Discord validates the endpoint.</p>"},{"location":"01.events/","title":"Events","text":"<p>Events are the bread and butter of how bots know what's happening on Discord. They are received over the gateway bot's connection and let us detect anything from someone joining or leaving a guild to moderation action to people creating messages.</p> <pre><code>bot = hikari.GatewayBot(\"TOKEN\")\n\n@bot.listen()\nasync def on_event(event: hikari.MessageCreateEvent) -&gt; None:\n    if not event.is_human:\n        return  # Ignore message creates from non-humans (so bots and webhooks).\n\n    if event.message == \"Hello Botto\":\n        await event.message.respond(\"Good morning human-kyun\")\n</code></pre> <p>In this basic example we listen for message create events from actual users and send the response message <code>\"Good morning human-kyun\"</code> if the content matches `\"Hello Botto\".</p> <p>Remember \"intents\" which were mentioned briefly earlier, well these are important here as we have to make sure that the correct intents are enabled for the events we want the bot to listen for when creating hikari.GatewayBot. More information on which intents are needed for an event can be found at hikari.Intents and if an event isn't mentioned in this list then it is always enabled.</p> <p>It should especially be noted that the message create event that examples listens for is considered \"privileged\" by Discord meaning that you have to enable them in Discord's application settings before the bot can declare them.</p> <p></p> <p>First go to the \"Bot\" section of the application you want to enable these settings for.</p> <p></p> <p>Then scroll down until you reach \"Privileged Gateway Intents\" and enable the intents you need. The presence intent lets the bot monitor the statuses of guild members, the server member intent lets the bot track who is in a server, and the message content intent lets the bot see every message users send (without this the bot will only see the content of messages which mention it).</p> <pre><code>bot = hikari.GatewayBot(\"TOKEN\")\ndb: DatabaseProto\n\n@bot.listen(hikari.StartingEvent)\nasync def on_starting_event(event: hikari.StartingEvent) -&gt; None:\n    await db.start()  # Start our database client while Hikari is starting.\n\nasync def on_stopping_event(event: hikari.StoppedEvent) -&gt; None:\n    await db.stop()  # Stop our database client when Hikari is stopping..\n\nbot.subscribe(hikari.StoppedEvent, on_stopping_event)\n</code></pre> <p>Hikari provides 4 event types which can be used for managing state around the client's lifetime:</p> <ul> <li>hikari.StartingEvent: called when the bot's starting</li> <li>hikari.StartedEvent: called when the bot's finished starting</li> <li>hikari.StoppingEvent: called when the bot's started closing</li> <li>hikari.StoppedEvent: called when the bot's finished closing</li> </ul> <p>It should be noted that Tanjun provides its own lifetime management system on-top which isn't tied to the bot type you're using. More information on this can be found in Tanjun's guide here.</p> <pre><code>async def handle_edit(bot: hikari.GatewayBot, message: hikari.Message) -&gt; None:\n    try:\n        edit_event = await bot.wait_for(\n            hikari.MessageUpdateEvent,\n            timeout=60,\n            predicate=lambda event: event.message_id == message.id,\n        )\n\n    except asyncio.TimeoutError:\n        # In this example we try to delete the message if it's not edited by\n        # author within 60 seconds.\n        try:\n            await message.delete()\n\n        # ForbiddenError will be raised if the bot can no-longer access the channel.\n        # and NotFoundError will be raised if the message doesn't exist anymore.\n        # We ignore these expected cases and return early to guard against the\n        # edit handling logic being called.\n        except (hikari.ForbiddenError, hikari.NotFoundError):\n            return\n\n    # ... Handle edit.\n</code></pre> <p>GatewayBot.wait_for can be used to wait for the next received event which matches a type and predicate (filter). In the above example we wait wait 60 seconds for a message update event where <code>event.message_id</code> matches a specific message and process the next edit or delete the message if we don't get a response in time.</p> <pre><code>async def stream_follow_ups(\n    bot: hikari.GatewayBot, channel: hikari.PartialChannel\n) -&gt; None:\n    iterator = bot.stream(hikari.MessageCreateEvent, timeout=5).filter(\n        (\"event.channel_id\", channel.id)\n    )\n\n    with iterator:\n        async for event in iterator:\n            ...  # ... process message create\n</code></pre> <p>GatewayBot.stream provides an asynchronous iterator which you can use to iterate over events as they're received. This comes with several chainable methods such as the filter method (more information on which can be found on LazyIterator) and will cache events received between iterations. The <code>limit</code> keyword argument can be used to limit how many events are cached and, while <code>timeout</code> defaults to None (unlimited) for this, you likely want use <code>timeout</code> to specify how many seconds it should wait between events before ending iteration.</p> <p>Just a final note, frameworks which build on top of Hikari will have their own abstractions and approaches of handling listening to events.</p> <pre><code>component = tanjun.Component()\n\n@component.with_listener()\nasync def on_member_event(\n    event: typing.Union[hikari.MemberCreateEvent, hikari.MemberUpdateEvent]\n):\n    ...\n\n@component.with_listener(hikari.StartedEvent, hikari.StartingEvent)\nasync def on_event(event: hikari.Event):\n    ...\n</code></pre> <p>Tanjun (while minimally invasive) tracks event listeners primarily through its \"Components\" using the decorator method Component.with_listener and the method Component.add_listener which add dependency injection support to event dispatch and register the relevant event listeners when the Tanjun client is started; <code>with_listener</code> adds support for unions when parsing event types from the callback's signature but otherwise matches GatewayBot.listen.</p>"},{"location":"02.commands/","title":"Commands","text":"<p>While you can make commands without Hikari, this guide Prioritise normal custom id match over prefix in components</p>"},{"location":"03.components/","title":"Components","text":"<p>Coming soon.</p>"},{"location":"04.permissions/","title":"Permissions","text":"<p>Coming soon.</p>"},{"location":"05.rest/","title":"REST","text":"<p>Coming soon.</p>"},{"location":"06.users/","title":"Users","text":"<p>Coming soon.</p>"},{"location":"07.webhooks/","title":"Webhooks","text":"<p>Bots aren't the only way you can send messages on Discord. Webhooks allow you to programmatically send messages to the Discord channel they're linked to.</p>"},{"location":"08.oauth2/","title":"Oauth2","text":"<p>Coming soon.</p>"},{"location":"09.serverless/","title":"Serverless","text":"<p>While Hikari's standard RESTBot implementation works by running an AIOHTTP server, this isn't the only way you can listen to interactions as a REST server.</p> <pre><code>bot = yuyo.AsgiBot(os.environ[\"TOKEN\"].strip(), \"Bot\")\ntanjun.Client.from_rest_bot(bot, bot_managed=True)\n\n# ... Other bot setup.\n\napp = fastapi.FastAPI()\n\napp.mount(\"/bot\", bot)\n</code></pre> <p>The utility library Yuyo provides an ASGI implementation of RESTBot which allows for running an interaction server with any ASGI v3 compatible REST server. The above examples shows this being used as a sub-app in a FastAPI server but <code>ASGIBot</code> can otherwise be used as the \"app\" when running using an ASGI web server implementation like Uvicorn or Gunicorn.</p> <pre><code>bot = yuyo.AsgiBot(os.environ[\"TOKEN\"].strip(), \"Bot\")\n\n# ... Setup bot\n\nentry_point = agraffe.Agraffe(bot)\n</code></pre> <p>Thanks to the flexibility of the ASGI standard, this can also be used with serverless frameworks people have implemented ASGI adapters for. The above example uses agraffe to create an entry point for AWS Lambdas, Azure Functions, or Google Cloud Functions.</p>"},{"location":"10.voice/","title":"Voice","text":"<p>Coming soon.</p>"}]}