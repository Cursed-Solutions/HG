{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started","text":"<p>Hikari is a powerful Python library which lets you program bots to do all sorts of things on Discord.</p> <p>Before using this guide to learn Hikari it's recommended that you make sure you understand basic concepts and how they work in Python such as object-oriented, and asynchronous programming. This knowledge is really important for properly grasping libraries like Hikari.</p> <p>If that all seems like a bit much for you and you don't really have a firm grasp on Python yet then I recommend trying a basics course (like Real Python) before using Hikari as libraries like this can be challenging to use without that foundational knowledge.</p>"},{"location":"#making-a-bot","title":"Making a bot","text":"<p>So to start off we should work out what type of bot you want to use.</p>"},{"location":"#gateway-bots","title":"Gateway bots","text":"<pre><code>cache_components = (\n    hikari.api.CacheComponents.GUILD_CHANNELS\n    | hikari.api.CacheComponents.ROLES\n    | hikari.api.CacheComponents.GUILDS\n    | hikari.api.CacheComponents.MEMBERS\n)\nbot = hikari.GatewayBot(\n    os.environ[\"TOKEN\"].strip(),\n    cache_settings=hikari.impl.CacheSettings(components=cache_components),\n    intents=hikari.Intents.ALL_UNPRIVILEGED,\n)\n\nactivity = hikari.Activity(\n    name=\"Hello world!\", type=hikari.ActivityType.LISTENING\n)\nbot.run(activity=activity)\n</code></pre> <p>Gateway bots are what you'll most likely want. These allow you to listen for actions happening on Discord by subscribing to events. All a gateway bot needs to work is a bot token, and an internet connection which can reach Discord and maintain a persistent connection.</p> <p>The example above shows how you'd initiate and the standard gateway bot implementation, it should be noted that the only required argument here is the token (first argument). The other arguments configure what entities this should cache in-process and the \"intents\" which indicate what events the bot wants to receive, more information on these can be found in events.</p>"},{"location":"#rest-server-bots","title":"REST server bots","text":"<pre><code>bot = hikari.RESTBot(os.environ[\"TOKEN\"].strip(), \"Bot\")\n\nbot.run(path=\"192.168.1.102\", port=8000)\n</code></pre> <p>While there's a lot less direct configuration to RESTBots than Gateway bot, there's a bit more to getting it working than with Gateway bot. The RESTBot runs a REST server which is meant to receive interaction requests from Discord; this limits it to only knowing when users actively interact with the bot through using components and slash commands but also means that before this can work you need to have the network setup to allow Discord to connect to your bot.</p> <p>The example above shows how you'd initiate the standard REST bot implementation, it should be noted that the only requirement arguments here are the token (first argument) and the token type (second argument). Before this this'll work though you'll need to have that pesky networking setup; this means having a domain name with ssl support which points towards the IP the RESTBot is behind (Discord won't accept a raw IP address). You should keep the RESTBot behind a reverse proxy with ssl enabled locally instead of exposing it straight to the public internet to keep the payloads encrypted in-transit.</p> <p></p> <p>Once you've got the networking setup and the bot running you'll want to enter the bot's web address here to tell Discord to start sending interaction requests to the bot. You should see a failed Ping request before a successful one in the logs as Discord validates the endpoint.</p>"},{"location":"01.events/","title":"Events","text":"<p>Events are the bread and butter of how bots know what's happening on Discord. They are received over the gateway bot's connection and let us detect anything from someone joining or leaving a guild to moderation action to people creating messages.</p> <pre><code>bot = hikari.GatewayBot(\"TOKEN\")\n\n@bot.listen()\nasync def on_event(event: hikari.MessageCreateEvent) -&gt; None:\n    if not event.is_human:\n        return  # Ignore message creates from non-humans (so bots and webhooks).\n\n    if event.message == \"Hello Botto\":\n        await event.message.respond(\"Good morning human-kyun\")\n</code></pre> <p>In this basic example we listen for message create events from actual users and send the response message <code>\"Good morning human-kyun\"</code> if the content matches `\"Hello Botto\".</p>"},{"location":"01.events/#intents","title":"Intents","text":"<p>Remember \"intents\" which were mentioned briefly earlier, well these are important here as we have to make sure that the correct intents are enabled for the events we want the bot to listen for when creating hikari.GatewayBot. More information on which intents are needed for an event can be found at hikari.Intents and if an event isn't mentioned in this list then it is always enabled.</p>"},{"location":"01.events/#privileged-intents","title":"Privileged intents","text":"<p>An important point to note is that the message create event that examples listens for is considered \"privileged\" by Discord meaning that you have to enable them in Discord's application settings before the bot can declare them.</p> <p></p> <p>First go to the \"Bot\" section of the application you want to enable these settings for.</p> <p></p> <p>Then scroll down until you reach \"Privileged Gateway Intents\" and enable the intents you need. The presence intent lets the bot monitor the statuses of guild members, the server member intent lets the bot track who is in a server, and the message content intent lets the bot see every message users send (without this the bot will only see the content of messages which mention it).</p>"},{"location":"01.events/#client-lifetimes","title":"Client lifetimes","text":"<pre><code>bot = hikari.GatewayBot(\"TOKEN\")\ndb: DatabaseProto\n\n@bot.listen(hikari.StartingEvent)\nasync def on_starting_event(event: hikari.StartingEvent) -&gt; None:\n    await db.start()  # Start our database client while Hikari is starting.\n\nasync def on_stopping_event(event: hikari.StoppedEvent) -&gt; None:\n    await db.stop()  # Stop our database client when Hikari is stopping..\n\nbot.subscribe(hikari.StoppedEvent, on_stopping_event)\n</code></pre> <p>Hikari provides 4 event types which can be used for managing state around the client's lifetime:</p> <ul> <li>hikari.StartingEvent: called when the bot's starting</li> <li>hikari.StartedEvent: called when the bot's finished starting</li> <li>hikari.StoppingEvent: called when the bot's started closing</li> <li>hikari.StoppedEvent: called when the bot's finished closing</li> </ul> <p>It should be noted that Tanjun provides its own lifetime management system on-top which isn't tied to the bot type you're using. More information on this can be found in Tanjun's guide here.</p>"},{"location":"01.events/#wait-for-an-event","title":"Wait for an event","text":"<pre><code>async def handle_edit(bot: hikari.GatewayBot, message: hikari.Message) -&gt; None:\n    try:\n        edit_event = await bot.wait_for(\n            hikari.MessageUpdateEvent,\n            timeout=60,\n            predicate=lambda event: event.message_id == message.id,\n        )\n\n    except asyncio.TimeoutError:\n        # In this example we try to delete the message if it's not edited by\n        # author within 60 seconds.\n        try:\n            await message.delete()\n\n        # ForbiddenError will be raised if the bot can no-longer access the channel.\n        # and NotFoundError will be raised if the message doesn't exist anymore.\n        # We ignore these expected cases and return early to guard against the\n        # edit handling logic being called.\n        except (hikari.ForbiddenError, hikari.NotFoundError):\n            return\n\n    # ... Handle edit.\n</code></pre> <p>GatewayBot.wait_for can be used to wait for the next received event which matches a type and predicate (filter). In the above example we wait 60 seconds for a message update event where <code>event.message_id</code> matches a specific message and process the next edit or delete the message if we don't get a response in time.</p>"},{"location":"01.events/#event-streams","title":"Event streams","text":"<pre><code>async def stream_follow_ups(\n    bot: hikari.GatewayBot, channel: hikari.PartialChannel\n) -&gt; None:\n    iterator = bot.stream(hikari.MessageCreateEvent, timeout=5).filter(\n        (\"event.channel_id\", channel.id)\n    )\n\n    with iterator:\n        async for event in iterator:\n            ...  # ... process message create\n</code></pre> <p>GatewayBot.stream provides an asynchronous iterator which you can use to iterate over events as they're received. This comes with several chainable methods such as the filter method (more information on which can be found on LazyIterator) and will cache events received between iterations. The <code>limit</code> keyword argument can be used to limit how many events are cached and, while <code>timeout</code> defaults to None (unlimited) for this, you likely want use <code>timeout</code> to specify how many seconds it should wait between events before ending iteration.</p>"},{"location":"01.events/#event-handling-in-frameworks","title":"Event handling in frameworks","text":"<p>Just a final note, frameworks which build on top of Hikari will have their own abstractions and approaches of handling listening to events.</p> <pre><code>component = tanjun.Component()\n\n@component.with_listener()\nasync def on_member_event(\n    event: hikari.MemberCreateEvent | hikari.MemberUpdateEvent,\n):\n    ...\n\n@component.with_listener(hikari.StartedEvent, hikari.StartingEvent)\nasync def on_event(event: hikari.Event):\n    ...\n</code></pre> <p>Tanjun (while minimally invasive) tracks event listeners primarily through its \"Components\" using the decorator method Component.with_listener and the method Component.add_listener which add dependency injection support to event dispatch and register the relevant event listeners when the Tanjun client is started; <code>with_listener</code> adds support for unions when parsing event types from the callback's signature but otherwise matches GatewayBot.listen.</p>"},{"location":"02.commands/","title":"Commands","text":"<p>While you can make commands without Hikari, this guide is only going to cover using a command client to make them as they make it a lot easier.</p> <p>These examples will be using Tanjun. Tanjun is a command framework which wraps around Hikari to provide ways declare and handle both modern application (slash) commands, traditional message (prefix) commands, and context menus.</p>"},{"location":"02.commands/#making-commands","title":"Making commands","text":""},{"location":"02.commands/#slash-commands","title":"Slash commands","text":"<p>Slash commands are the commands you'll see in Discord when you start by \"/\" in the message box.</p> <pre><code>@tanchan.doc_parse.with_annotated_args\n@tanchan.doc_parse.as_slash_command(\n    default_to_ephemeral=True,\n    dm_enabled=False,\n    default_member_permissions=hikari.Permissions.BAN_MEMBERS,\n)\nasync def ban_user(\n    ctx: tanjun.abc.SlashContext,\n    user: tanjun.annotations.User,\n    reason: tanjun.annotations.Str | hikari.UndefinedType = hikari.UNDEFINED,\n) -&gt; None:\n\"\"\"Ban a user.\n\n    Parameters\n    ----------\n    user\n        The user to ban.\n    reason\n        Why they're being banned.\n    \"\"\"\n    assert ctx.guild_id is not None\n\n    try:\n        await ctx.rest.ban_member(ctx.guild_id, user, reason=reason)\n\n    except hikari.NotFoundError:\n        await ctx.respond(\"User doesn't exist!!!\")\n\n    except hikari.ForbiddenError:\n        await ctx.respond(\"I Cannot do that!!!\")\n\n    else:\n        await ctx.respond(f\"Successfully banned {user}\")\n</code></pre> <p> </p> <p>There's a few things going on in this example.</p> <p>First off, tanchan.doc_parse.as_slash_command is used to create a command by wrapping a command callback while using the callback's name (ban_user) as the command's name and using the first line of its docstring as the slash command's description.</p> <p>Then tanchan.doc_parse.with_annotated_args parses the function's parameter type-hints to work out the slash command's options while parsing per-option descriptions from the docstring's \"Parameters\" section.</p> <p>It should be noted that Tanchan is a separate optional utility library which builds ontop of the system tanjun provides in tanjun.annotations to add support for docstring parsing.</p> <pre><code>slash_command_group = tanjun.slash_command_group(\"group\", \"description\")\n\n@slash_command_group.as_sub_command(\"name\", \"description\")\nasync def sub_command(ctx: tanjun.abc.SlashContext) -&gt; None:\n    await ctx.respond(\"Called `group name` command\")\n</code></pre>"},{"location":"02.commands/#prefix-commands","title":"Prefix commands","text":""},{"location":"02.commands/#context-menus","title":"Context menus","text":""},{"location":"02.commands/#checks","title":"Checks","text":""},{"location":"02.commands/#more-annotated-types","title":"More annotated types","text":""},{"location":"02.commands/#loading-commands","title":"Loading commands","text":"<p>Tanjun doesn't let you load commands directly into its clients, instead you need to create a tanjun.Component instance and load the commands into it then load that into the client.</p> <p>There's 2 different ways to load commands into a component:</p>"},{"location":"02.commands/#loading-into-clients","title":"Loading into clients","text":"<p>For more information on Tanjun's features (including features not covered here and other ways to declare commands) see its usage guide.</p>"},{"location":"03.components/","title":"Components","text":"<p>Coming soon (pending some refactors to Hikari).</p>"},{"location":"04.permissions/","title":"Permissions","text":"<p>Coming soon.</p>"},{"location":"05.rest/","title":"REST","text":"<p>Coming soon.</p>"},{"location":"06.users/","title":"Users","text":"<p>Coming soon.</p>"},{"location":"07.webhooks/","title":"Webhooks","text":"<p>Coming soon.</p>"},{"location":"08.oauth2/","title":"Oauth2","text":"<p>Coming soon.</p>"},{"location":"09.serverless/","title":"Serverless","text":""},{"location":"09.serverless/#asgi","title":"ASGI","text":"<p>While Hikari's standard RESTBot implementation works by running an AIOHTTP server, this isn't the only way you can listen to interactions as a REST server.</p> <pre><code>bot = yuyo.AsgiBot(os.environ[\"TOKEN\"].strip(), \"Bot\")\ntanjun.Client.from_rest_bot(bot, bot_managed=True)\n\n# ... Other bot setup.\n\napp = fastapi.FastAPI()\n\napp.mount(\"/bot\", bot)\n</code></pre> <p>The utility library Yuyo provides an ASGI implementation of RESTBot which allows for running an interaction server with any ASGI v3 compatible REST server. The above examples shows this being used as a sub-app in a FastAPI server but <code>ASGIBot</code> can otherwise be used as the \"app\" when running using an ASGI web server implementation like Uvicorn or Gunicorn.</p> <pre><code>bot = yuyo.AsgiBot(os.environ[\"TOKEN\"].strip(), \"Bot\")\n\n# ... Setup bot\n\nentry_point = agraffe.Agraffe(bot)\n</code></pre> <p>Thanks to the flexibility of the ASGI standard, this can also be used with serverless frameworks people have implemented ASGI adapters for. The above example uses agraffe to create an entry point for AWS Lambdas, Azure Functions, or Google Cloud Functions.</p>"},{"location":"10.voice/","title":"Voice","text":"<p>Coming soon.</p>"}]}