{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started","text":"<p>Hikari is a powerful Python library which lets you program bots to do all sorts of things on Discord.</p> <p>Before using this guide to learn Hikari it's recommended that you make sure you understand basic concepts and how they work in Python such as object-oriented, and asynchronous programming. This knowledge is really important for properly grasping libraries like Hikari.</p> <p>If that all seems like a bit much for you and you don't really have a firm grasp on Python yet then I recommend trying a basics course (like Real Python) before using Hikari as libraries like this can be challenging to use without that foundational knowledge.</p>"},{"location":"#making-a-bot","title":"Making a bot","text":"<p>So to start off we should work out what type of bot you want to use.</p>"},{"location":"#gateway-bots","title":"Gateway bots","text":"<pre><code>cache_components = (\n    hikari.api.CacheComponents.GUILD_CHANNELS\n    | hikari.api.CacheComponents.ROLES\n    | hikari.api.CacheComponents.GUILDS\n    | hikari.api.CacheComponents.MEMBERS\n)\nbot = hikari.GatewayBot(\n    os.environ[\"TOKEN\"].strip(),\n    cache_settings=hikari.impl.CacheSettings(components=cache_components),\n    intents=hikari.Intents.ALL_UNPRIVILEGED,\n)\n\nactivity = hikari.Activity(\n    name=\"Hello world!\", type=hikari.ActivityType.LISTENING\n)\nbot.run(activity=activity)\n</code></pre> <p>Gateway bots are what you'll most likely want. These allow you to listen for actions happening on Discord by subscribing to events. All a gateway bot needs to work is a bot token, and an internet connection which can reach Discord and maintain a persistent connection.</p> <p>The example above shows how you'd initiate and the standard gateway bot implementation, it should be noted that the only required argument here is the token (first argument). The other arguments configure what entities this should cache in-process and the intents which indicate what events the bot wants to receive, more information on these can be found in events.</p>"},{"location":"#rest-server-bots","title":"REST server bots","text":"<pre><code>bot = hikari.RESTBot(os.environ[\"TOKEN\"].strip(), \"Bot\")\n\nbot.run(path=\"192.168.1.102\", port=8000)\n</code></pre> <p>While there's a lot less direct configuration to RESTBots than Gateway bot, there's a bit more to getting it working than with Gateway bot. The RESTBot runs a REST server which is meant to receive interaction requests from Discord; this limits it to only knowing when users actively interact with the bot through using components and slash commands but also means that before this can work you need to have the network setup to allow Discord to connect to your bot.</p> <p>The example above shows how you'd initiate the standard REST bot implementation, it should be noted that the only requirement arguments here are the token (first argument) and the token type (second argument). Before this this'll work though you'll need to have that pesky networking setup; this means having a domain name with ssl support which points towards the IP the RESTBot is behind (Discord won't accept a raw IP address). You should keep the RESTBot behind a reverse proxy with ssl enabled locally instead of exposing it straight to the public internet to keep the payloads encrypted in-transit.</p> <p></p> <p>Once you've got the networking setup and the bot running you'll want to enter the bot's web address here to tell Discord to start sending interaction requests to the bot. You should see a failed Ping request before a successful one in the logs as Discord validates the endpoint.</p>"},{"location":"01.events/","title":"Events","text":"<p>Events are the bread and butter of how bots know what's happening on Discord. They are received over the gateway bot's connection and let us detect anything from someone joining or leaving a guild to moderation action to people creating messages.</p> <pre><code>bot = hikari.GatewayBot(\"TOKEN\")\n\n@bot.listen()\nasync def on_event(event: hikari.MessageCreateEvent) -&gt; None:\n    if not event.is_human:\n        return  # Ignore message creates from non-humans (so bots and webhooks).\n\n    if event.message.content == \"Hello Botto\":\n        await event.message.respond(\"Good morning human-kyun\")\n</code></pre> <p>In this basic example we listen for message create events from actual users and send the response message <code>\"Good morning human-kyun\"</code> if the content matches `\"Hello Botto\".</p>"},{"location":"01.events/#intents","title":"Intents","text":"<p>Remember \"intents\" which were mentioned briefly earlier, well these are important here as we have to make sure that the correct intents are enabled for the events we want the bot to listen for when creating hikari.GatewayBot. More information on which intents are needed for an event can be found at hikari.Intents and if an event isn't mentioned in this list then it is always enabled.</p>"},{"location":"01.events/#privileged-intents","title":"Privileged intents","text":"<p>An important point to note is that the message create event that examples listens for is considered \"privileged\" by Discord meaning that you have to enable them in Discord's application settings before the bot can declare them.</p> <p></p> <p>First go to the \"Bot\" section of the application you want to enable these settings for.</p> <p></p> <p>Then scroll down until you reach \"Privileged Gateway Intents\" and enable the intents you need. The presence intent lets the bot monitor the statuses of guild members, the server member intent lets the bot track who is in a server, and the message content intent lets the bot see every message users send (without this the bot will only see the content of messages which mention it).</p>"},{"location":"01.events/#client-lifetimes","title":"Client lifetimes","text":"<pre><code>bot = hikari.GatewayBot(\"TOKEN\")\ndb: DatabaseProto\n\n@bot.listen(hikari.StartingEvent)\nasync def on_starting_event(event: hikari.StartingEvent) -&gt; None:\n    await db.start()  # Start our database client while Hikari is starting.\n\nasync def on_stopping_event(event: hikari.StoppedEvent) -&gt; None:\n    await db.stop()  # Stop our database client when Hikari is stopping..\n\nbot.subscribe(hikari.StoppedEvent, on_stopping_event)\n</code></pre> <p>Hikari provides 4 event types which can be used for managing state around the client's lifetime:</p> <ul> <li>hikari.StartingEvent: called when the bot's starting</li> <li>hikari.StartedEvent: called when the bot's finished starting</li> <li>hikari.StoppingEvent: called when the bot's started closing</li> <li>hikari.StoppedEvent: called when the bot's finished closing</li> </ul> <p>It should be noted that Tanjun provides its own lifetime management system on-top which isn't tied to the bot type you're using. More information on this can be found in Tanjun's guide here.</p>"},{"location":"01.events/#wait-for-an-event","title":"Wait for an event","text":"<pre><code>async def handle_edit(bot: hikari.GatewayBot, message: hikari.Message) -&gt; None:\n    try:\n        edit_event = await bot.wait_for(\n            hikari.MessageUpdateEvent,\n            timeout=60,\n            predicate=lambda event: event.message_id == message.id,\n        )\n\n    except asyncio.TimeoutError:\n        # In this example we try to delete the message if it's not edited by\n        # author within 60 seconds.\n        try:\n            await message.delete()\n\n        # ForbiddenError will be raised if the bot can no-longer access the channel.\n        # and NotFoundError will be raised if the message doesn't exist anymore.\n        # We ignore these expected cases and return early to guard against the\n        # edit handling logic being called.\n        except (hikari.ForbiddenError, hikari.NotFoundError):\n            return\n\n    # ... Handle edit.\n</code></pre> <p>GatewayBot.wait_for can be used to wait for the next received event which matches a type and predicate (filter). In the above example we wait 60 seconds for a message update event where <code>event.message_id</code> matches a specific message and process the next edit or delete the message if we don't get a response in time.</p>"},{"location":"01.events/#event-streams","title":"Event streams","text":"<pre><code>async def stream_follow_ups(\n    bot: hikari.GatewayBot, channel: hikari.PartialChannel\n) -&gt; None:\n    iterator = bot.stream(hikari.MessageCreateEvent, timeout=5).filter(\n        (\"event.channel_id\", channel.id)\n    )\n\n    with iterator:\n        async for event in iterator:\n            ...  # ... process message create\n</code></pre> <p>GatewayBot.stream provides an asynchronous iterator which you can use to iterate over events as they're received. This comes with several chainable methods such as the filter method (more information on which can be found on LazyIterator) and will cache events received between iterations. The <code>limit</code> keyword argument can be used to limit how many events are cached and, while <code>timeout</code> defaults to None (unlimited) for this, you likely want use <code>timeout</code> to specify how many seconds it should wait between events before ending iteration.</p>"},{"location":"01.events/#event-handling-in-frameworks","title":"Event handling in frameworks","text":"<p>Just a final note, frameworks which build on top of Hikari will have their own abstractions and approaches of handling listening to events.</p> <pre><code>component = tanjun.Component()\n\n@component.with_listener()\nasync def on_member_event(\n    event: hikari.MemberCreateEvent | hikari.MemberUpdateEvent,\n):\n    ...\n\n@component.with_listener(hikari.StartedEvent, hikari.StartingEvent)\nasync def on_event(event: hikari.Event):\n    ...\n</code></pre> <p>Tanjun (while minimally invasive) tracks event listeners primarily through its \"Components\" using the decorator method Component.with_listener and the method Component.add_listener which add dependency injection support to event dispatch and register the relevant event listeners when the Tanjun client is started; <code>with_listener</code> adds support for unions when parsing event types from the callback's signature but otherwise matches GatewayBot.listen.</p>"},{"location":"02.commands/","title":"Commands","text":"<p>Slash commands are the commands you'll see in Discord when you start by \"/\" in the message box.</p> <p>This guide is only going to cover using a command client to make commands as, while you can make commands with just Hikari, command clients makes it a lot easier and is the recommended approach.</p> <p>These examples will be using Tanjun. Tanjun is a command framework which wraps around Hikari to provide ways declare and handle both modern application (slash) commands, traditional message (prefix) commands, and context menus.</p>"},{"location":"02.commands/#making-slash-commands","title":"Making Slash commands","text":"<pre><code>@tanchan.doc_parse.with_annotated_args\n@tanchan.doc_parse.as_slash_command(\n    default_to_ephemeral=True,\n    dm_enabled=False,\n    default_member_permissions=hikari.Permissions.BAN_MEMBERS,\n)\nasync def ban_user(\n    ctx: tanjun.abc.SlashContext,\n    user: annotations.User,\n    reason: annotations.Str | hikari.UndefinedType = hikari.UNDEFINED,\n) -&gt; None:\n\"\"\"Ban a user.\n\n    Parameters\n    ----------\n    user\n        The user to ban.\n    reason\n        Why they're being banned.\n    \"\"\"\n    # guild_id should never be None thanks to dm_enabled=False\n    assert ctx.guild_id is not None\n\n    try:\n        await ctx.rest.ban_member(ctx.guild_id, user, reason=reason)\n\n    except hikari.NotFoundError:\n        await ctx.respond(\"User doesn't exist!!!\")\n\n    except hikari.ForbiddenError:\n        await ctx.respond(\"I Cannot do that!!!\")\n\n    else:\n        await ctx.respond(f\"Successfully banned {user}\")\n</code></pre> <p>There's a few things going on in this example:</p> <p>First off, tanchan.doc_parse.as_slash_command is used to create a slash command by wrapping a command callback. This is using the callback's name (\"ban_user\") as the command's name and using the first line of its docstring as the slash command's description.</p> <p>Then tanchan.doc_parse.with_annotated_args parses the function's parameter type-hints to work out the slash command's options while parsing per-option descriptions from the docstring's \"Parameters\" section.</p> <p>This example uses <code>default_member_permissions</code> to mark the command as limited to only members who have permission to ban users unless this configuration is overridden by guild staff. It also uses <code>dm_only</code> to marks the command as only working in guilds.</p> <p>It should be noted that Tanchan is a separate optional utility library which builds on top of the system tanjun provides in tanjun.annotations to add support for docstring parsing.</p>"},{"location":"02.commands/#ephemeral-responses","title":"Ephemeral responses","text":"<p>The \"only you can see this\" responses you're seeing here are called ephemeral responses, these are unique to slash and context menu commands. While this example uses <code>default_to_ephemeral=True</code> to mark all the command's responses as ephemeral, you can also pass <code>ephemeral=True</code> while calling AppCommandContext.create_initial_response or AppCommandContext.create_followup to mark individual responses as ephemeral.</p>"},{"location":"02.commands/#slash-command-groups","title":"Slash command groups","text":"<pre><code>slash_command_group = tanchan.doc_parse.slash_command_group(\n    \"group\", \"description\"\n)\n\n@slash_command_group.as_sub_command()\nasync def name(ctx: tanjun.abc.SlashContext) -&gt; None:\n\"\"\"`group name` command.\"\"\"\n    await ctx.respond(\"Called `group name` command\")\n</code></pre> <p>Since normal slash commands can't have spaces in their names, you have to use slash command \"groups\" to get spaces. These are limited to only being nested once (so a slash command group can be put in a top-level group but can't then put a group in that sub-group) and some configuration is limited to top level commands so for what you can configure for sub-commands see SlashCommandGroup.as_sub_command and SlashCommandGroup.make_sub_group.</p>"},{"location":"02.commands/#making-message-commands","title":"Making message commands","text":"<p>Message commands are the classic command approach which listens for user messages which start with a certain prefix or bot mention and then processes the rest of the message's content for command execution.</p> <p>The <code>{GUILD}|{DM}_MESSAGES</code> intent has to be enabled for these commands to work and without the privileged hikari.Intents.MESSAGE_CONTENT intent command execution will only work for mention prefixes.</p> <p>Since these match based on the prefix, you must also set some prefix for the client to match against using either tanjun.clients.Client.add_prefix or by passing <code>mention_prefix=True</code> when initialising the bot (calling Client.from_gateway_bot).</p> <pre><code>@tanjun.annotations.with_annotated_args\n@tanjun.as_message_command(\"meow\")\nasync def message_command(\n    ctx: tanjun.abc.MessageContext, weebish: tanjun.annotations.Bool = False\n) -&gt; None:\n    ...\n</code></pre> <p>The above example shows a message command that would be triggered by <code>{prefix}meow</code> and where the \"weebish\" argument can optionally be provided by sending <code>{prefix}weebish true</code>.</p> <pre><code>@tanjun.as_message_command_group(\"uwu group\")\nasync def message_command_group(ctx: tanjun.abc.MessageContext) -&gt; None:\n    ...\n\n@tanjun.annotations.with_annotated_args\n@message_command_group.as_sub_command(\"echo\")\nasync def sub_command(\n    ctx: tanjun.abc.MessageContext,\n    content: typing.Annotated[annotations.Str, annotations.Greedy()],\n) -&gt; None:\n    ...\n</code></pre> <p>The above example takes advantage of message command groups to group sub-commands together. The group itself will be callable as <code>{prefix}uwu group</code> and the sub-command will be callable as <code>{prefix}uwu group echo {content...}</code>. <code>Greedy</code> marks this argument as taking the rest of the positional arguments and doesn't effect slash commands.</p>"},{"location":"02.commands/#making-context-menus","title":"Making context menus","text":"<p>Context menu commands are the simplest of the 3. These are the buttons you see when you right click on a user or message under \"Apps\". These have similar configuration to slash commands but cannot be nested, have more relaxed name restrictions and do not have descriptions nor options.</p>"},{"location":"02.commands/#message-context-menus","title":"Message context menus","text":"<pre><code>@tanjun.as_message_menu(\"Archive\", dm_enabled=False)\nasync def message_menu(\n    ctx: tanjun.abc.MenuContext, message: hikari.Message\n) -&gt; None:\n    # ... Archive logic\n    try:\n        await ctx.rest.delete_message(ctx.channel_id, message)\n\n    except hikari.NotFoundError:\n        pass\n\n    except hikari.ForbiddenError:\n        await ctx.respond(\"Couldn't delete message\", delete_after=30)\n        return\n\n    await ctx.respond(\"Archived message\", delete_after=30)\n</code></pre> <p>There's message context menus which will always take hikari.Message positionally as their 2nd argument.</p>"},{"location":"02.commands/#user-context-menus","title":"User context menus","text":"<pre><code>@tanjun.as_user_menu(\"Yeet user\")\nasync def user_menu(\n    ctx: tanjun.abc.MenuContext, user: hikari.InteractionMember\n) -&gt; None:\n    # ... Yetting logic\n    await ctx.respond(f\"{user} got yeeted!\", delete_after=30)\n</code></pre> <p>And there's user context menus which will always take hikari.InteractionMember positionally as their 2nd argument.</p> <p>These examples use <code>delete_after</code> to tell Tanjun to delete the response after 30 seconds if it still exists.</p>"},{"location":"02.commands/#multi-commands","title":"Multi-commands","text":"<pre><code>@tanchan.doc_parse.with_annotated_args(follow_wrapped=True)\n@tanchan.doc_parse.as_slash_command()\n@tanjun.as_message_command(\"meow command\")\n@tanjun.as_user_menu(\"meow command\")\nasync def command(ctx: tanjun.abc.Context, user: annotations.User) -&gt; None:\n\"\"\"Do a thing to a user.\n\n    Parameters\n    ----------\n    user\n        The user to do the thing to.\n    \"\"\"\n    # ... Thing logic\n    await ctx.respond(f\"Thing done to {user}\")\n</code></pre> <p>When you want to use a command callback for multiple commands types there are a few things you'll have to note. The bases classes of tanjun.abc.Context or tanjun.abc.AppCommandContext (if this is only being used for slash and menu commands) should be used to type the first argument as these are base classes which only have cross-compatible features present (e.g. ephemeral responses are not implemented for the base <code>Context</code> as this isn't supported by message commands).</p> <p>Command decorators like tanchan.doc_parse.with_annotated_args and the <code>with_{}_check</code> decorators present in tanjun.checks come with an optional <code>follow_wrapped</code> argument. Setting this to True will make it apply the decorator's change to every compatible command declaration in that decorator chain (rather than just the one it's directly on).</p> <p>Since context menus take their only value (the user or message) positionally as the second argument you'll have to make sure the relevant option can be passed both positionally (as the 2nd argument) and by its name.</p>"},{"location":"02.commands/#checks","title":"Checks","text":"<p>Checks are callbacks which decide whether a command or group of commands should run for a command execution context. There's a collection of checks in tanjun.checks which can be applied to any command type.</p> <p>These can be added to commands through decorator calls (e.g. <code>@tanjun.with_guild_check</code>) or by calling <code>command.add_check(check)</code>.</p>"},{"location":"02.commands/#loading-commands","title":"Loading commands","text":"<p>Tanjun doesn't let you load commands directly into its clients, instead you need to create a tanjun.Component instance and load the commands into it then load that into the client.</p> <p>There's 2 different ways to load commands into a component:</p> <pre><code>component = tanjun.Component()\n\n@component.with_command(follow_wrapped=True)\n@tanjun.as_slash_command(\"name\", \"description\")\n@tanjun.as_message_command(\"name\")\nasync def command(ctx: tanjun.abc.Context) -&gt; None:\n    ...\n\n@tanjun.as_slash_command(\"name\", \"description\")\nasync def other_command(ctx: tanjun.abc.Context) -&gt; None:\n    ...\n\ncomponent.add_command(other_command)\n</code></pre> <p>If you build the component first then you can use the Component.add_command and Component.with_command methods to add commands to the component directly. <code>with_command</code> supports <code>follow_wrapped</code>.</p> <pre><code>@tanjun.as_slash_command(\"name\", \"description\")\nasync def slash_command(ctx: tanjun.abc.SlashContext) -&gt; None:\n    ...\n\ncomponent = tanjun.Component().load_from_scope()\n</code></pre> <p>Alternatively, you can call <code>load_from_scope</code> at the end of the module to load command objects (plus some other objects like schedules) into the component from the module's top level automatically.</p>"},{"location":"02.commands/#loading-into-clients","title":"Loading into clients","text":"<pre><code>component = tanjun.Component()\n\n# ...\n\nloaders = component.make_loader()\n</code></pre> <p>Component loaders give an easy way to load functionality and commands into a tanjun client from a module.</p> <pre><code>(\n    tanjun.Client.from_gateway_bot(bot, declare_global_commands=True)\n    .load_directory(\"./components\", namespace=\"bot.components\")\n    .load_modules(\"bot.admin\")\n)\n\nbot.run()\n</code></pre> <p>Normally you'd load modules straight into the client as shown in the example above. Client.load_modules loads from specific modules while Client.load_directory loads from the modules directly in a directory (no recursion). While <code>load_modules</code> takes python module paths (same paths you use in <code>import</code> syntax), <code>load_directory</code> takes a system path and the python module path for that directory as the keyword argument <code>namespace</code>. The namespace is appended onto python file names as <code>f\"{namespace}.{path.name[:3]}\"</code>.</p> <pre><code>bot = hikari.GatewayBot(\"Token\")\nclient = tanjun.Client.from_gateway_bot(bot)\n\n(\n    tanjun.dependencies.HotReloader()\n    .add_directory(\"./components\", namespace=\"bot.components\")\n    .add_modules(\"bot.admin\")\n    .add_to_client(client)\n)\n\nbot.run()\n</code></pre> <p>Tanjun also provides a standard hot reloader implementation which has a similar interface to Client for marking modules to track and will reload or unload target modules when it detects a that its file has been changed. tanjun.HotReloader will also redeclare application commands when they're changed unless <code>redeclare_cmds_after=None</code> is passed to its init.</p> <p>Only one of these approaches should be used at the time since they'll conflict with each other.</p>"},{"location":"02.commands/#see-you-space-cowboy","title":"See You Space Cowboy","text":"<p>For more information on Tanjun's features (including features not covered here and other ways to declare commands) see its usage guide.</p>"},{"location":"03.components/","title":"Message Components","text":"<p>Message components are the interactive buttons and select menus you'll see on messages sent by bots.</p> <p>This guide is only going to cover using Yuyo's components client to make and handle components as, while you can use components with just Hikari, higher level clients make it a lot easier and is the recommended approach.</p>"},{"location":"03.components/#making-components","title":"Making components","text":"<pre><code>class LinkColumn(components.ActionColumnExecutor):\n    @components.as_button(hikari.ButtonStyle.DANGER)\n    async def on_button(self, ctx: components.Context) -&gt; None:\n        await ctx.respond(\"Button pressed\")\n\n    link_button = components.link_button(\"htts://example.com/yee\")\n</code></pre> <p>The above examples shows using yuyo.components.ActionColumnExecutor to declare and handle message buttons.</p> <p></p> <p>There are several different \"styles\" of buttons, as shown above. Most button styles are interactive (meaning that the bot will be told when they're pressed) except link buttons, which opens the relevant link in a browser for the user who clicked it.</p> <pre><code>class SelectColumn(components.ActionColumnExecutor):\n    @components.as_channel_select\n    async def on_channel_select(self, ctx: components.Context) -&gt; None:\n        await ctx.respond(f\"Selected {len(ctx.select_channels)} channels\")\n\n    @components.with_option(\"borf\", \"dog\")\n    @components.with_option(\"meow\", \"cat\")\n    @components.with_option(\"label\", \"value\")\n    @components.as_text_select(min_values=0, max_values=3)\n    async def on_text_select(self, ctx: components.Context) -&gt; None:\n        await ctx.respond(\"Animals: \" + \", \".join(ctx.select_texts))\n\n    @components.as_select_menu(hikari.ComponentType.ROLE_SELECT_MENU)\n    async def on_role_select(self, ctx: components.Context) -&gt; None:\n        roles = \", \".join(role.name for role in ctx.select_roles.values())\n        await ctx.respond(f\"Selected roles: {roles}\")\n\n    @components.as_select_menu(hikari.ComponentType.USER_SELECT_MENU)\n    async def on_user_select(self, ctx: components.Context) -&gt; None:\n        users = \", \".join(map(str, ctx.select_users.values()))\n        await ctx.respond(f\"Selected users: {users}\")\n\n    @components.as_select_menu(hikari.ComponentType.MENTIONABLE_SELECT_MENU)\n    async def on_mentionable_select(self, ctx: components.Context) -&gt; None:\n        role_count = len(ctx.select_roles)\n        user_count = len(ctx.select_users)\n        await ctx.respond(f\"Selected {user_count} users and {role_count} roles\")\n</code></pre> <p></p> <p>Message components also include select menus. These allow users to select 1 or more options (dependent on the configured <code>min_values</code> and <code>max_values</code>), telling the bot which options they've picked. Most select menu types will pre-populate options for users (whether that be users, channels, or roles), but text select menus require the bot to pre-define up to 25 string options for it.</p> <p>By default <code>min_values</code> is set to <code>0</code> and <code>max_values</code> is set to <code>1</code>, but <code>max_values</code> can be set to up to <code>25</code> to allow the user to select multiple options before finalising (sending) the interaction.</p>"},{"location":"03.components/#rows","title":"Rows","text":"<p>While ActionColumnExecutor abstracts away building individual, action rows you still need to be aware of the restrictions around them:</p> <ul> <li>A message can have up to 5 rows.</li> <li>A row can only contain one select menu.</li> <li>A row can contain up to 5 buttons (regardless of the style).</li> </ul> <p>ActionColumnExecutor will always append components to the last row if possible or add a new row. this means that if your second row only has 1 button but there's a 3rd which is a select menu then an add button call would add a 4th row for the button.</p>"},{"location":"03.components/#sending-components","title":"Sending components","text":"<pre><code>@tanjun.as_slash_command(\"name\", \"description\")\nasync def command(\n    ctx: tanjun.abc.Context, client: alluka.Injected[components.ComponentClient]\n) -&gt; None:\n    component = SelectColumn()\n    message = await ctx.respond(\n        \"hello!\", components=component.rows, ensure_result=True\n    )\n    client.set_executor(message, component)\n</code></pre>"},{"location":"03.components/#and-now-for-something-completely-different","title":"And now for something completely different","text":"<p>This guide only covers one of Yuyo's different approaches for declaring and handling components, only giving a basic overview. For more information on Yuyo's components functionality see its usage guide.</p>"},{"location":"04.modals/","title":"Modals","text":"<p>Modals allow bots to prompt users for more information as the initial response for a slash command, context menu or message component interaction.</p> <p>This guide is only going to cover using Yuyo's Modal client to make and handle modals as, while you can use modals with just Hikari, higher level clients make it a lot easier and is the recommended approach.</p>"},{"location":"04.modals/#making-modals","title":"Making modals","text":"<pre><code>@modals.as_modal_template\nasync def modal_template(\n    ctx: modals.ModalContext,\n    name: str = modals.text_input(\n        \"name\", placeholder=\"What is their name?\", max_length=20\n    ),\n    reason: str = modals.text_input(\n        \"reason\",\n        default=\"Still likes harry potter.\",\n        style=hikari.TextInputStyle.PARAGRAPH,\n    ),\n) -&gt; None:\n    await ctx.respond(f\"{name} is sussy because they {reason}\")\n</code></pre> <p>Modals take the shape of dialogue boxes which show up on top of everything else with the above example showing up in the client like this:</p> <p></p> <p>The only supported field type for modals is \"text inputs\" right now. A modal can have up to 5 text inputs in it, each taking up to 4000 characters. The bot will not be told if a modal pop up was cancelled or closed without submission.</p>"},{"location":"04.modals/#sending-modals","title":"Sending modals","text":"<pre><code>async def command(\n    ctx: tanjun.abc.AppCommandContext, client: alluka.Injected[modals.ModalClient]\n) -&gt; None:\n    modal = modal_template()\n    client.set_modal(\"custom_id\", modal)\n    await ctx.create_modal_response(\n        \"Who's sussy?\", \"custom_id\", components=modal.rows\n    )\n</code></pre> <p>As shown above, creating a modal in response to a slash command, context menu, or message component use is simple. First you register this modal instance to a top-level custom ID by calling ModalClient.set_modal (which defaults to 1 use and a 10 second timeout). Then you can pass Modal.rows to <code>create_modal_response</code> as <code>components</code> alongside the top-level custom ID and the model's title. A modal can only be triggered as the first response (before deferring).</p>"},{"location":"04.modals/#rows","title":"Rows","text":"<p>Modals also have the concept of \"rows\" in a similar sense to message components and Modal also handles creating new rows for you. Right now text inputs always take up a whole row.</p>"},{"location":"04.modals/#row-row-fight-the-power","title":"Row! Row! Fight the power!","text":"<p>This guide only covers one of Yuyo's approaches for declaring modals and only gives a basic overview. For more information on Yuyo's modals functionality see its usage guide.</p>"},{"location":"09.serverless/","title":"Serverless","text":""},{"location":"09.serverless/#asgi","title":"ASGI","text":"<p>While Hikari's standard RESTBot implementation works by running an AIOHTTP server, this isn't the only way you can listen to interactions as a REST server.</p> <pre><code>bot = yuyo.AsgiBot(os.environ[\"TOKEN\"].strip(), \"Bot\")\ntanjun.Client.from_rest_bot(bot, bot_managed=True)\n\n# ... Other bot setup.\n\napp = fastapi.FastAPI()\n\napp.mount(\"/bot\", bot)\n</code></pre> <p>The utility library Yuyo provides an ASGI implementation of RESTBot which allows for running an interaction server with any ASGI v3 compatible REST server. The above examples shows this being used as a sub-app in a FastAPI server but <code>ASGIBot</code> can otherwise be used as the \"app\" when running using an ASGI web server implementation like Uvicorn or Gunicorn.</p> <pre><code>bot = yuyo.AsgiBot(os.environ[\"TOKEN\"].strip(), \"Bot\")\n\n# ... Setup bot\n\nentry_point = agraffe.Agraffe(bot)\n</code></pre> <p>Thanks to the flexibility of the ASGI standard, this can also be used with serverless frameworks people have implemented ASGI adapters for. The above example uses agraffe to create an entry point for AWS Lambdas, Azure Functions, or Google Cloud Functions.</p>"}]}