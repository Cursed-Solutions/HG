# Commands

While you can make commands without Hikari, this guide is only going to cover
using a command client to make them as they make it a lot easier.

These examples will be using [Tanjun](https://github.com/FasterSpeeding/Tanjun).
Tanjun is a command framework which wraps around Hikari to provide ways declare
and handle both modern application (slash) commands, traditional message
(prefix) commands, and context menus.

### Making Slash commands

Slash commands are the commands you'll see in Discord when you start by "/" in
the message box.

```py
--8<-- "./docs_src/commands.py:17:50"
```

![find_intents_1](./images/slash_command_example_1.png){ width=49% }
![find_intents_2](./images/slash_command_example_2.png){ width=49% }

There's a few things going on in this example:

First off, [tanchan.doc_parse.as_slash_command][] is used to create a slash command
by wrapping a command callback. This is using the callback's name ("ban_user") as
the command's name and using the first line of its docstring as the slash
command's description.

Then [tanchan.doc_parse.with_annotated_args][] parses the function's parameter
type-hints to work out the slash command's options while parsing per-option
descriptions from the docstring's "Parameters" section.

This example uses `default_member_permissions` to mark the command as
limited to only members who have permission to ban users unless this
configuration is overridden by guild staff. It also uses `dm_only` to
marks the command as only working in guilds.

It should be noted that [Tanchan](https://github.com/FasterSpeeding/Tan-chan)
is a separate optional utility library which builds on top of the system tanjun
provides in [tanjun.annotations][] to add support for docstring parsing.

##### Ephemeral responses

The "only you can see this" responses you're seeing here are called
ephemeral responses, these are unique to slash and context menu commands.
While this example uses `default_to_ephemeral=True` to mark all the command's
responses as ephemeral, you can also pass `ephemeral=True` while calling
[AppCommandContext.create_initial_response][tanjun.abc.AppCommandContext.create_initial_response]
or [AppCommandContext.create_followup][tanjun.abc.AppCommandContext.create_followup]
to mark individual responses as ephemeral.

##### Slash command groups

```py
--8<-- "./docs_src/commands.py:54:61"
```

![slash_command_group_example.png](./images/slash_command_group_example.png)

Since normal slash commands can't have spaces in their names, you have to use
slash command "groups" to get spaces. These are limited to only being nested
once (so a slash command group can be put in a top-level group but can't then
put a group in that sub-group) and some configuration is limited to top level
commands so for what you can configure for sub-commands see
[SlashCommandGroup.as_sub_command][tanjun.commands.slash.SlashCommandGroup.as_sub_command] and
[SlashCommandGroup.make_sub_group][tanjun.commands.slash.SlashCommandGroup.make_sub_group].

### Making message commands

```py
--8<-- "./docs_src/commands.py:65:68"
```



```py
--8<-- "./docs_src/commands.py:72:78"
```

### Making context menus

Context menu commands are the simplest of the 3. These are the buttons you see
when you right click on a user or message under "Apps". These have similar
configuration to slash commands but cannot be nested, have more relaxed name
restrictions and do not have descriptions nor options.


##### Message context menus

```py
--8<-- "./docs_src/commands.py:91:106"
```

![find_intents_1](./images/message_menu_example.png)

There's message context menus which will always take
[hikari.Message][hikari.messages.Message] positionally as their 2nd argument.


##### User context menus

```py
--8<-- "./docs_src/commands.py:82:87"
```

![find_intents_1](./images/user_menu_example.png)

And there's user context menus which will always take
[hikari.InteractionMember][hikari.interactions.base_interactions.InteractionMember]
positionally as their 2nd argument.

These examples use `delete_after` to tell Tanjun to delete the response after 30
seconds if it still exists.

### Multi-commands


```py
--8<-- "./docs_src/commands.py:110:125"
```

### Checks

### More annotated types

### Loading commands

Tanjun doesn't let you load commands directly into its clients, instead you
need to create a [tanjun.Component][tanjun.components.Component] instance and
load the commands into it then load that into the client.

There's 2 different ways to load commands into a component:


```py
--8<-- "./docs_src/commands.py:137:149"
```

If you build the component first then you can use the
[Component.add_command][tanjun.components.Component.add_command] and
[Component.with_command][tanjun.components.Component.with_command] methods
to add commands to the component directly. `with_command` supports
`follow_wrapped`.

```py
--8<-- "./docs_src/commands.py:129:133"
```

Alternatively, you can call `load_from_scope` at the end of the module to
load command objects (plus some other objects like schedules) into the
component from the module's top level automatically.

### Loading into clients

```py
--8<-- "./docs_src/commands.py:153:157"
```

```py
--8<-- "./docs_src/commands.py:161:168"
```

```py
--8<-- "./docs_src/commands.py:172:182"
```

For more information on Tanjun's features (including features not covered here and
other ways to declare commands) see its [usage guide](https://tanjun.cursed.solutions/usage/).
